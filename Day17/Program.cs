using System;
using System.Collections.Generic;
using System.Numerics;
using System.Linq;

namespace Day17
{
    class Program
    {
        static int INSTR_COUNT = 3;
        static int MEMORY_CAPACITY = 20;
        static BigInteger A = (BigInteger)'A';
        static BigInteger B = (BigInteger)'B';
        static BigInteger C = (BigInteger)'C';
        static BigInteger YES = (BigInteger)'y';
        static BigInteger NO = (BigInteger)'n';
        static BigInteger SEPARATOR = (BigInteger)',';
        static BigInteger END = (BigInteger)'\n';


        #region Part 1
        /// <summary>
        /// Get the output generated by the intcode computer and populate the scaffolds list with all the scaffold found.
        /// </summary>
        /// <param name="output">List output by the computer</param>
        /// <param name="scaffolds">List of the scaffolds' position to populate</param>
        /// <returns>The statrting position of the robot and its direction</returns>
        static (int x, int y, int d) GenerateScaffolds(List<BigInteger> output, List<(int x, int y)> scaffolds)
        {
            (int x, int y) pos = (0, 0);
            (int x, int y, int d) robot = (0, 0, 0);
            foreach (BigInteger square in output)
            {
                switch ((char)square)
                {
                    case '#':
                        scaffolds.Add(pos);
                        break;
                    case '\n':
                        pos.y++;
                        pos.x = -1;
                        break;
                    case '^':
                        robot.x = pos.x;
                        robot.y = pos.y;
                        robot.d = 0;
                        break;
                    case 'v':
                        robot.x = pos.x;
                        robot.y = pos.y;
                        robot.d = 2;
                        break;
                    case '>':
                        robot.x = pos.x;
                        robot.y = pos.y;
                        robot.d = 1;
                        break;
                    case '<':
                        robot.x = pos.x;
                        robot.y = pos.y;
                        robot.d = 3;
                        break;
                }
                pos.x++;
            }
            return robot;
        }

        /// <summary>
        /// Get the alignment parameters of the crossroads. The alignment parameter is the position x of the scaffold multiplied by its y position.
        /// </summary>
        /// <param name="output">The list output by the computer</param>
        /// <returns>The sum of all the parameters</returns>
        static int GetAlignmentParameters(List<BigInteger> output)
        {
            List<(int x, int y)> scaffolds = new List<(int, int)>();
            GenerateScaffolds(output, scaffolds);
            int alignment = 0;
            foreach ((int x, int y) scaffold in scaffolds)
            {
                if (scaffolds.Contains((scaffold.x - 1, scaffold.y)) && scaffolds.Contains((scaffold.x, scaffold.y - 1)) &&
                    scaffolds.Contains((scaffold.x + 1, scaffold.y)) && scaffolds.Contains((scaffold.x, scaffold.y + 1)))
                {
                    alignment += scaffold.x * scaffold.y;
                }
            }
            return alignment;
        }
        #endregion

        #region Part 2
        /// <summary>
        /// Get the next forward position based on a position and a direction.
        /// </summary>
        /// <param name="x">Current x position</param>
        /// <param name="y">Current y position</param>
        /// <param name="dir">Current direction</param>
        /// <returns>The next forward position</returns>
        static (int x, int y) GetNext(int x, int y, int dir)
        {
            dir = (dir < 0 ? 4 + dir : dir) % 4;
            if (dir % 2 == 0)
            {
                return ((x, dir == 0 ? y - 1 : y + 1));
            }
            return ((dir == 1 ? x + 1 : x - 1, y));
        }

        /// <summary>
        /// Get the available scaffolds next to the robot. The scaffolds have to be either in front or on the side, as we don't want the robot to backtrack.
        /// </summary>
        /// <param name="robot">Current position and direction of the robot</param>
        /// <param name="scaffolds">List of the scaffolds</param>
        /// <returns>A nullable tuple containing the 3 possible positions. If a position is unavailable, its value is null.</returns>
        static ((int x, int y)? left, (int x, int y)? right, (int x, int y)? forward) GetAvailableMoves((int x, int y, int d) robot, List<(int x, int y)> scaffolds)
        {
            ((int x, int y)? left, (int x, int y)? right, (int x, int y)? forward) moves = (null, null, null);
            (int x, int y) nextSquare = GetNext(robot.x, robot.y, robot.d);
            if (scaffolds.Contains(nextSquare))
            {
                moves.forward = nextSquare;
            }
            nextSquare = GetNext(robot.x, robot.y, robot.d + 1);
            if (scaffolds.Contains(nextSquare))
            {
                moves.right = nextSquare;
            }
            nextSquare = GetNext(robot.x, robot.y, robot.d - 1);
            if (scaffolds.Contains(nextSquare))
            {
                moves.left = nextSquare;
            }
            return moves;
        }

        /// <summary>
        /// Move the robot 1 square forward.
        /// </summary>
        /// <param name="robot">Reference to the robot</param>
        static void MoveRobot(ref (int x, int y, int d) robot)
        {
            (int x, int y) pos = GetNext(robot.x, robot.y, robot.d);
            robot.x = pos.x;
            robot.y = pos.y;
        }

        /// <summary>
        /// Change the robot's direction.
        /// </summary>
        /// <param name="robot">Reference to the robot</param>
        /// <param name="turn">Turn rate. Positive for right, negative for left</param>
        static void TurnRobot(ref (int x, int y, int d) robot, int turn)
        {
            robot.d = (robot.d + turn % 4) % 4;
            if (robot.d < 0)
            {
                robot.d += 4;
            }
        }

        /// <summary>
        /// Return the sequence of actions the robot will have to do to reach the end of the scaffolds. R and L are converted to their int value.
        /// As the scaffolds form a nice path that can be followed as a single corridor, the robot always go forward as much as possible and then turn right or left.
        /// Would not work if the map was a maze.
        /// </summary>
        /// <param name="output">The list outputed by the computer</param>
        /// <returns>The list of movement the robot has to do to reach the end of the scaffolds</returns>
        static List<int> GetMovementSequence(List<BigInteger> output)
        {
            List<(int x, int y)> scaffolds = new List<(int x, int y)>();
            List<int> sequence = new List<int>();
            (int x, int y, int d) robot = GenerateScaffolds(output, scaffolds);
            ((int x, int y)? left, (int x, int y)? right, (int x, int y)? forward) next = GetAvailableMoves(robot, scaffolds);
            while (next.left != null || next.right != null || next.forward != null)
            {
                if (next.forward != null)
                {
                    int dist = 0;
                    while (next.forward != null)
                    {
                        ++dist;
                        MoveRobot(ref robot);
                        next = GetAvailableMoves(robot, scaffolds);
                    }
                    sequence.Add(dist);
                }
                else
                {
                    if (next.right != null)
                    {
                        sequence.Add((int)'R');
                        TurnRobot(ref robot, 1);
                    }
                    else
                    {
                        sequence.Add((int)'L');
                        TurnRobot(ref robot, -1);
                    }
                    next = GetAvailableMoves(robot, scaffolds);
                }
            }
            return sequence;
        }

        /// <summary>
        /// Check if a range is inside a list of ranges.
        /// </summary>
        /// <param name="pos">The starting position of the range to check</param>
        /// <param name="length">The length of the range to check</param>
        /// <param name="ranges">The list of ranges to consult</param>
        /// <returns>True if the range overlap another range in the list, false otherwise</returns>
        static bool IsInRange(int pos, int length, List<(int i, int l, int)> ranges)
        {
            foreach (var r in ranges)
            {
                if ((pos >= r.i && pos < r.i + r.l) || (pos + length - 1 >= r.i && pos + length - 1 < r.i + r.l))
                {
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Insert an occurence inside the list of the split commands. The occurence is inserted at its correct position based on the positional value (i)
        /// </summary>
        /// <param name="split">The list of split commands</param>
        /// <param name="pos">Position of the occurence</param>
        /// <param name="length">Length of the occurence</param>
        /// <param name="sId">Depth of the occurence (0 A, 1 B, 2 C)</param>
        static void InsertOccurences(List<(int i, int l, int sId)> split, List<int> pos, int length, int sId)
        {
            foreach (int p in pos)
            {
                int i = 0;
                for (; i < split.Count && split[i].i < p; ++i) { }
                if (i == split.Count)
                {
                    split.Add((p, length, sId));
                }
                else
                {
                    split.Insert(i, (p, length, sId));
                }
            }
        }

        /// <summary>
        /// Create a copy of the current split commands and add a new temporary occurence inside.
        /// </summary>
        /// <param name="split">The list of split commands</param>
        /// <param name="pos">The position of the occurence</param>
        /// <param name="length">The lenght of the occurence</param>
        /// <param name="sId">The depth of the occurence</param>
        /// <returns>The copy of the split commands list with the new occurence added</returns>
        static List<(int i, int l, int sId)> CreateDummySplit(List<(int i, int l, int sId)> split, List<int> pos, int length, int sId)
        {
            List<(int i, int l, int sId)> dummy = new List<(int i, int l, int sId)>(split);
            InsertOccurences(dummy, pos, length, sId);
            return dummy;
        }
        
        /// <summary>
        /// Check if the split command is possible. This is done by adding all the split commands length and comparing it with the size of the sequence.
        /// </summary>
        /// <param name="sequence">The sequence of commands</param>
        /// <param name="split">The split commands</param>
        /// <returns>True if the split is possible, false otherwise</returns>
        static bool IsCorrectSplit(List<int> sequence, List<(int i, int l, int sId)> split)
        {
            return split.Select(s => s.l).Sum() == sequence.Count;
        }

        /// <summary>
        /// Split the command sequence recursively. The algo starts at zero as it has to be the start of the first function. It then takes all the same occurence of this command in the sequence.
        /// Then it adds another input of the sequence and check if all the other occurence are still similar, removing them if it's not the case.
        /// The recursion starts from here, trying the same process from the first available sequence position that is not inside the occurences found on the previous level of the recursion.
        /// The recursion continues as such until the command is splitted into multiple occurences all belonging to a maximum variety of 3.
        /// </summary>
        /// <param name="sequence">The sequence of commands</param>
        /// <param name="tmp">A temporary split command list to test the previous recursion occurences</param>
        /// <param name="sId">The depth of the recursion. Max 3 (0->2)</param>
        /// <param name="split">The split commands to populate. Only the correct occurences will be addded</param>
        /// <returns>True if the function managed to split the sequence, false otherwise</returns>
        static bool SplitRec(List<int> sequence, List<(int i, int l, int sId)> tmp, int sId, List<(int i, int l, int sId)> split)
        {
            bool check = IsCorrectSplit(sequence, tmp);
            if (sId >= INSTR_COUNT || check)
            {
                return check && tmp.Count <= MEMORY_CAPACITY / 2;
            }
            int pos = 0;
            List<int> occ = new List<int>();
            for (int i = 0; i < tmp.Count; ++i)
            {
                if (tmp[i].i == pos)
                {
                    pos += tmp[i].l;
                }
            }
            for (int length = 1; length <= MEMORY_CAPACITY / 2; ++length)
            {
                if (length == 1)
                {
                    for (int i = pos; i + length < sequence.Count; ++i)
                    {
                        if (sequence[pos] == sequence[i + length - 1])
                        {
                            occ.Add(i + length - 1);
                        }
                    }
                }
                else
                {
                    for (int i = occ.Count - 1; i >= 0; --i)
                    {
                        if (occ[i] + length - 1 >= sequence.Count || sequence[occ[i] + length - 1] != sequence[occ[0] + length - 1] || IsInRange(occ[i], length, tmp))
                        {
                            occ.RemoveAt(i);
                        }
                    }
                    if (occ.Count == 0)
                    {
                        break;
                    }
                    if (SplitRec(sequence, CreateDummySplit(tmp, occ, length, sId), sId + 1, split))
                    {
                        InsertOccurences(split, occ, length, sId);
                        return true;
                    }
                }
            }
            return false;
        }

        /// <summary>
        /// Start of the SplitRec recursion. Used to initialize the values needed.
        /// </summary>
        /// <param name="sequence">The sequence of commands</param>
        /// <returns>The list of split commands</returns>
        static List<(int i, int l, int sId)> SplitSequence(List<int> sequence)
        {
            List<(int i, int l, int sId)> split = new List<(int i, int l, int sId)>();
            if (!SplitRec(sequence, split, 0, split))
            {
                Advent2019.Utils.FatalError("Unable to split the movement sequence into " + INSTR_COUNT + " instructions.");
            }
            return split;
        }

        /// <summary>
        /// Transform a routine into ascii for the computer.
        /// </summary>
        /// <param name="instructions">The list of instructions to populate</param>
        /// <param name="routine">The routine to convert</param>
        /// <param name="sequence">The default sequence of command</param>
        static void AddRoutine(List<BigInteger> instructions, (int i, int l, int sId) routine, List<int> sequence)
        {
            for (int i = routine.i; i < routine.i + routine.l; ++i)
            {
                BigInteger val = sequence[i];
                if (val != 82 && val != 76 && val >= 10)
                {
                    instructions.Add((val / 2).ToString()[0]);
                    instructions.Add(SEPARATOR);
                    instructions.Add((val / 2 + val % 2).ToString()[0]);
                }
                else
                {
                    instructions.Add(val != 82 && val != 76 ? val.ToString()[0] : val);
                }
                if (i + 1 < routine.i + routine.l)
                {
                    instructions.Add(SEPARATOR);
                }
            }
            instructions.Add(END);
        }

        /// <summary>
        /// Find the movement commands needed for the robot to pass through all the scaffolds, then split it into 3 sub-sections, convert it to ascii instructions and feed it to the computer.
        /// </summary>
        /// <param name="computer">Intcode computer</param>
        /// <param name="output">Output of the previous execution of the computer</param>
        /// <returns>The amount of dust collected</returns>
        static int GetCollectedDust(IntcodeComputer computer, List<BigInteger> output)
        {
            computer.EditMemory(0, 2);
            List<int> sequence = GetMovementSequence(output);
            List<(int i, int l, int sId)> routines = SplitSequence(sequence);
            List<BigInteger> instructions = new List<BigInteger>();
            for (int i = 0; i < routines.Count; ++i)
            {
                switch (routines[i].sId)
                {
                    case 0:
                        instructions.Add(A);
                        break;
                    case 1:
                        instructions.Add(B);
                        break;
                    case 2:
                        instructions.Add(C);
                        break;
                }
                if (i + 1 < routines.Count)
                {
                    instructions.Add(SEPARATOR);
                }
            }
            instructions.Add(END);
            AddRoutine(instructions, routines.Where(r => r.sId == 0).First(), sequence);
            AddRoutine(instructions, routines.Where(r => r.sId == 1).First(), sequence);
            AddRoutine(instructions, routines.Where(r => r.sId == 2).First(), sequence);
            instructions.Add(NO);
            instructions.Add(END);
            List<BigInteger> result = computer.Execute(instructions.ToArray());
            return (int)result[result.Count - 1];
        }
        #endregion

        static void Main(string[] args)
        {
            IntcodeComputer computer = new IntcodeComputer(Advent2019.Utils.GetInput(args));
            List<BigInteger> output = computer.Execute();
            Console.WriteLine("Part 1: " + GetAlignmentParameters(output));
            Console.WriteLine("Part 2: " + GetCollectedDust(computer, output));
        }
    }
}
